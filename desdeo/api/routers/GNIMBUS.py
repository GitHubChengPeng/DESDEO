"""Router for GNIMBUS."""

from typing import Annotated, TypeVar
from collections import Counter

from fastapi import APIRouter, Depends, HTTPException
import numpy as np
from numpy import allclose
from pydantic import BaseModel, Field, ValidationError
from sqlalchemy.orm import Session

from desdeo.api.db import get_db
from desdeo.api.db_models import Preference, SolutionArchive, MethodState
from desdeo.api.db_models import Problem as ProblemInDB
from desdeo.api.routers.UserAuth import get_current_user
from desdeo.api.schema import User
from desdeo.mcdm.nimbus import generate_starting_point, solve_intermediate_solutions, solve_sub_problems
from desdeo.problem.schema import Problem

from desdeo.api.utils.database import (
    database_dependency,
    select,
    update,
    DatabaseDependency,
    DB,
)

from .NIMBUS import (
    FakeNIMBUSResponse,
    InitRequest,
    NIMBUSIterateRequest as NIMBUSIterateRequest,
    NIMBUSIntermediateSolutionRequest,
    SaveRequest as NIMBUSSaveRequest,
)

router = APIRouter(prefix="/gnimbus")

T = TypeVar("T")

class GroupRequest(BaseModel):
    """The request to navigate the GNIMBUS."""

    request_ids: list[int] = Field(description="List of id of saved requests.")
    cached: bool = Field(description="Determine whether to get saved results.", default=False)


class VoteRequest(InitRequest):
    """The vote request in GNIMBUS."""

    reference_solution_id: int = Field(description="The reference solution id as in the DB.")
    reference_solution: list[float] = Field(
        description="The reference solution value."
    )

class NIMBUSBasicResponse(BaseModel):
    """The basic response from GNIMBUS."""

    current_solutions: dict[int, list[float]] = Field(description="The current solutions.")


class NIMBUSFullResponse(NIMBUSBasicResponse):
    """The full response from initialize GNIMBUS endpoint."""

    objective_symbols: list[str] = Field(description="The symbols of the objectives.")
    objective_long_names: list[str] = Field(description="The names of the objectives.")
    units: list[str | None] | None = Field(description="The units of the objectives.")
    is_maximized: list[bool] = Field(description="Whether the objectives are to be maximized or minimized.")
    lower_bounds: list[float] = Field(description="The lower bounds of the objectives.")
    upper_bounds: list[float] = Field(description="The upper bounds of the objectives.")
    previous_preference: list[float] = Field(description="The previous preference used.")
    saved_solutions: dict[int, list[float]] = Field(description="The best candidate solutions saved by the decision maker.")
    new_solutions: dict[int, list[float]] = Field(description="The newly generated solutions from the current interation of nimbus.")
    all_solutions: dict[int, list[float]] = Field(description="All solutions generated by NIMBUS in all iterations.")
    chosen_solutions: dict[int, list[float]] = Field(description="Chosen solutions selected by the decision maker.")


class NIMBUSIterateResponse(NIMBUSBasicResponse):
    """The response from iterate endpoint."""

    previous_preference: list[float] = Field(description="The previous preference used.")
    new_solutions: dict[int, list[float]] = Field(description="The newly generated solutions from the current interation of nimbus.")
    all_solutions: dict[int, list[float]] = Field(description="All solutions generated.")


class NIMBUSSaveResponse(BaseModel):
    """The response from save endpoint."""

    saved_solutions: dict[int, list[float]] = Field(description="The best candidate solutions saved by the decision maker.")

class NIMBUSChosenResponse(NIMBUSBasicResponse):
    """The response from chosen NIMBUS."""

    chosen_solutions: dict[int, list[float]] = Field(description="All solutions generated by NIMBUS in all iterations.")

class NIMBUSIterateRequest(NIMBUSIterateRequest):
    """The request to iterate the GNIMBUS algorithm."""

    reference_solution_id: int = Field(description="The reference solution id as in the DB.")


class SaveRequest(NIMBUSSaveRequest):
    """The request to save the solutions."""

    solution_ids: list[int] = Field(description="The solution ids to be saved.")


class ChooseRequest(InitRequest):
    """The request to choose the final solution."""

    reference_solution_id: int = Field(description="The ID of the problem to be solved.")
    reference_solution: list[float] = Field(description="The chosen solution.")


@router.post("/initialize")
def init_nimbus(
    init_request: InitRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[Session, Depends(get_db)],
) -> NIMBUSFullResponse | FakeNIMBUSResponse:
    """Initialize the GNIMBUS algorithm.

    Args:
        init_request (InitRequest): The request to initialize the GNIMBUS.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db (Annotated[Session, Depends(get_db)]): The database session.

    Returns:
        NIMBUSFullResponse | FakeNIMBUSResponse: The response from the GNIMBUS algorithm.
    """

    problem_id = init_request.problem_id
    method_id = init_request.method_id
    problem = db.query(ProblemInDB).filter(ProblemInDB.id == problem_id).first()

    if problem is None:
        raise HTTPException(status_code=404, detail="Problem not found.")
    # if problem.owner != user.index and problem.owner is not None:
        # raise HTTPException(status_code=403, detail="Unauthorized to access chosen problem.")
    try:
        problem = Problem.model_validate(problem.value)
    except ValidationError:
        raise HTTPException(status_code=500, detail="Error in parsing the problem.") from ValidationError

    # See if there are previous solutions in the database for this problem
    solutions = (
        db.query(SolutionArchive)
        .filter(SolutionArchive.problem == problem_id)
        # .filter(SolutionArchive.user == user.index)
        .all()
    )

    ideal = problem.get_ideal_point()
    nadir = problem.get_nadir_point()

    if None in ideal or None in nadir:
        raise HTTPException(status_code=500, detail="Problem missing ideal or nadir value.")

    # If there are no solutions, generate a starting point for NIMBUS
    if not solutions:
        start_result = generate_starting_point(problem=problem)
        current_solution = SolutionArchive(
            user=user.index,
            problem=problem_id,
            method=method_id,
            decision_variables=list(start_result.optimal_variables.values()),
            objectives=list(start_result.optimal_objectives.values()),
            saved=False,
            new=True,
            current=True,
            chosen=False,
        )

        # Save the generated starting point to the db
        db.add(current_solution)
        db.commit()

        solutions = [current_solution]
    else:
        # If there is a solution marked as current, use that. Otherwise just use the first solution in the db
        current_solution = next((sol for sol in solutions if sol.current), solutions[0])

    lower_bounds = [0.0 for x in range(len(problem.objectives))]
    upper_bounds = [0.0 for x in range(len(problem.objectives))]

    for i in range(len(problem.objectives)):
        if problem.objectives[i].maximize:
            lower_bounds[i] = nadir[problem.objectives[i].symbol]
            upper_bounds[i] = ideal[problem.objectives[i].symbol]
        else:
            lower_bounds[i] = ideal[problem.objectives[i].symbol]
            upper_bounds[i] = nadir[problem.objectives[i].symbol]

    # return FakeNIMBUSResponse(message="NIMBUS initialized.")
    return NIMBUSFullResponse(
        objective_symbols=[obj.symbol for obj in problem.objectives],
        objective_long_names=[obj.name for obj in problem.objectives],
        units=[obj.unit for obj in problem.objectives],
        is_maximized=[obj.maximize for obj in problem.objectives],
        lower_bounds=lower_bounds,
        upper_bounds=upper_bounds,
        previous_preference=current_solution.objectives,
        new_solutions={sol.id: sol.objectives for sol in solutions if sol.new},
        current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
        saved_solutions={sol.id: sol.objectives for sol in solutions if sol.saved},
        all_solutions={sol.id: sol.objectives for sol in solutions},
        chosen_solutions={sol.id: sol.objectives for sol in solutions if sol.chosen}
    )

async def processGroupRequest(
    grequest: GroupRequest,
    db: Annotated[DB, Depends(database_dependency)]
) -> list[T]:
    """Process group request.

    Args:
        grequest (GroupRequest): The request to process.
        db (Annotated[DB, Depends(database_dependency)]): The database session.

    Returns:
        list[T]: The rows of requests submitted by DMs.
    """

    requestRows = await db.all(select(MethodState).filter(MethodState.id.in_(grequest.request_ids)))

    return requestRows


def getMostSelected(
    ids: list[int],
) -> list[int]:
    """Get most selected id.

    Args:
        ids (list[int]): List of ids.

    Returns:
        list[int]: The most selected id(s).
    """

    listCounter = Counter(ids)
    most_count = listCounter.most_common(1)[0][1]

    return [n[0] for n in listCounter.most_common() if n[1] == most_count]


async def getMostSelectedSolutions(
    db: Annotated[DB, Depends(database_dependency)],
    requests: list[VoteRequest | NIMBUSIterateRequest | ChooseRequest]
) -> dict[int, list[float]]:
    """Get most selected solutions.

    Args:
        db (Annotated[DB, Depends(database_dependency)]): The database session.
        requests: list[VoteRequest | NIMBUSIterateRequest | ChooseRequest]: List of requests.

    Returns:
        dict[int, list[float]]: List of most selected solutions.
    """

    reference_solutions = {request.reference_solution_id: request.reference_solution for request in requests}
    reference_solutions_ids = [request.reference_solution_id for request in requests]
    selected_ref_solution_ids = getMostSelected(reference_solutions_ids)

    await db.update(
        update(SolutionArchive)
        .where(SolutionArchive.id.in_(selected_ref_solution_ids))
        .values(current=True)
    )

    return {id: reference_solutions[id] for id in selected_ref_solution_ids}


@router.post("/solution-vote")
async def solutionVote(
    grequest: GroupRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSBasicResponse | FakeNIMBUSResponse:
    """Vote for a current solution.

    Args:
        grequest (GroupRequest): The request to vote.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSBasicResponse | FakeNIMBUSResponse: The response from the GNIMBUS vote endpoint.
    """

    requestRows = await processGroupRequest(grequest, db)
    requests = [VoteRequest.model_validate(requestRow.value) for requestRow in requestRows]

    if not grequest.cached:
        await db.update(
            update(SolutionArchive)
            .where(SolutionArchive.problem==requests[0].problem_id, SolutionArchive.current==True)
            .values(current=False)
        )

        reference_solutions = await getMostSelectedSolutions(db, requests)
        if len(reference_solutions) > 1:
            return NIMBUSBasicResponse(
                current_solutions=reference_solutions
            )

        selected_ref_solution_id = list(reference_solutions.keys())[0]
        vote_solution = await db.first(select(SolutionArchive).filter_by(id=selected_ref_solution_id))

        if vote_solution.chosen:
            await db.update(
                update(SolutionArchive)
                .where(SolutionArchive.problem==requests[0].problem_id, SolutionArchive.id!=selected_ref_solution_id)
                .values(chosen=False)
            )

        selected_reference_solution = list(reference_solutions.values())[0]

        return NIMBUSBasicResponse(
            current_solutions={selected_ref_solution_id: selected_reference_solution},
        )
    else:
        solutions = (
            await db.all(select(SolutionArchive)
            .filter_by(problem=requests[0].problem_id)
            .filter((SolutionArchive.current==True))
            .order_by(SolutionArchive.id.asc()))
        )

        return NIMBUSBasicResponse(
            current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
        )


@router.post("/iterate")
async def iterate(
    grequest: GroupRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSIterateResponse | FakeNIMBUSResponse:
    """Iterate the GNIMBUS algorithm.

    Args:
        grequest (GroupRequest): The request to vote.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSIterateResponse | FakeNIMBUSResponse: The response from the NIMBUS algorithm.
    """

    requestRows = await processGroupRequest(grequest, db)
    requests = [NIMBUSIterateRequest.model_validate(requestRow.value) for requestRow in requestRows]

    problem_id = requests[0].problem_id
    method_id = requests[0].method_id

    request = requests[0]

    problem = await db.first(select(ProblemInDB).filter_by(id=problem_id))
    if problem is None:
        raise HTTPException(status_code=404, detail="Problem not found.")
    # if problem.owner != user.index and problem.owner is not None:
        # raise HTTPException(status_code=403, detail="Unauthorized to access chosen problem.")
    try:
        problem = Problem.model_validate(problem.value)
    except ValidationError:
        raise HTTPException(status_code=500, detail="Error in parsing the problem.") from ValidationError

    if not grequest.cached:
        reference_solution = requests[0].reference_solution

        # Save the given preferences
        for r in requests:
            pref = Preference(
                user=user.index, problem=problem_id, method=method_id, kind="NIMBUS", value=r.model_dump(mode="json")
            )
            await db.add(pref)

        previous_solutions = (
            await db.all(select(SolutionArchive)
            .filter_by(problem=problem_id)
            .order_by(SolutionArchive.id.asc()))
        )

        if not previous_solutions:
            raise HTTPException(status_code=404, detail="Problem not found in the database.")

        ideal = problem.get_ideal_point()
        nadir = problem.get_nadir_point()
        if None in ideal or None in nadir:
            raise HTTPException(status_code=500, detail="Problem missing ideal or nadir value.")

        # Do NIMBUS stuff here.
        results = solve_sub_problems(
            problem=problem,
            current_objectives=dict(zip([obj.symbol for obj in problem.objectives], reference_solution, strict=True)),
            reference_point=dict(zip([obj.symbol for obj in problem.objectives], request.preference, strict=True)),
            num_desired=len(requests) - 1,
        )

        # See if the results include duplicates and remove them
        duplicate_indices = set()
        for i in range(len(results) - 1):
            for j in range(i + 1, len(results)):
                if allclose(list(results[i].optimal_objectives.values()), list(results[j].optimal_objectives.values())):
                    duplicate_indices.add(j)

        for index in sorted(list(duplicate_indices), reverse=True):
            results.pop(index)

        # Mark all the old solutions as not current
        await db.update(
            update(SolutionArchive)
            .where(SolutionArchive.problem==problem_id, SolutionArchive.new==True)
            .values(new=False)
            .returning(SolutionArchive)
        )

        solutions = {i: sol for i, sol in enumerate(previous_solutions)}
        solutionsToUpdate = set()
        for res in results:
            # Check if the results already exist in the database
            solutionIndex = -1
            for i, prev in solutions.items():
                if allclose(list(res.optimal_objectives.values()), list(prev.objectives)):
                    previous_solutions[i].new = True
                    solutions.pop(i)
                    solutionsToUpdate.add(previous_solutions[i].id)
                    solutionIndex = i
                    break

            # If the solution was not found in the database, add it
            if solutionIndex < 0 or not previous_solutions[solutionIndex].new:
                await db.add(
                    SolutionArchive(
                        user=user.index,
                        problem=problem_id,
                        method=method_id,
                        decision_variables=list(res.optimal_variables.values()),
                        objectives=list(res.optimal_objectives.values()),
                        saved=False,
                        current=False,
                        new=True,
                        chosen=False,
                    )
                )

        await db.update(
            update(SolutionArchive)
            .where(SolutionArchive.id.in_(solutionsToUpdate))
            .values(new=True)
        )

        await db.commit()

    solutions = (
        await db.all(select(SolutionArchive)
                    .filter_by(problem=problem_id)
                    .order_by(SolutionArchive.id.asc()))
    )

    all_solutions = {sol.id: sol.objectives for sol in solutions}
    current_solutions = {sol.id: sol.objectives for sol in solutions if sol.current}

    if not grequest.cached:
        if len(all_solutions) > 1:
            # Mark all the old solutions as not current
            old_current_solutions = await db.update(
                update(SolutionArchive)
                .where(SolutionArchive.problem==problem_id, SolutionArchive.current==True)
                .values(current=False)
                .returning(SolutionArchive)
            )

            current_solutions = {sol.id: sol.objectives for sol in old_current_solutions if sol.current}

    return NIMBUSIterateResponse(
        previous_preference=request.preference,
        new_solutions={sol.id: sol.objectives for sol in solutions if sol.new},
        current_solutions=current_solutions,
        all_solutions=all_solutions,
    )

@router.post("/save")
async def save(
    request: SaveRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSSaveResponse | FakeNIMBUSResponse:
    """Save the solutions to the database.

    Args:
        grequest (GroupRequest): The request to choose.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        The response from the NIMBUS algorithm.
    """

    saved_solutions = await db.update(
        update(SolutionArchive)
        .where(SolutionArchive.id.in_(request.solution_ids))
        .values(saved=True)
        .returning(SolutionArchive)
    )

    return NIMBUSSaveResponse(
        saved_solutions={sol.id: sol.objectives for sol in saved_solutions},
    )

@router.post("/choose")
async def choose(
    grequest: GroupRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[DB, Depends(database_dependency)],
) -> NIMBUSChosenResponse | FakeNIMBUSResponse:
    """Choose a solution as the final solution for NIMBUS.

    Args:
        grequest (GroupRequest): The request to choose.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db: Annotated[DB, Depends(database_dependency)]: The database session.

    Returns:
        NIMBUSChooseResponse | FakeNIMBUSResponse: The response from the NIMBUS algorithm.
    """

    requestRows = await processGroupRequest(grequest, db)
    requests = [ChooseRequest.model_validate(requestRow.value) for requestRow in requestRows]

    problem_id = requests[0].problem_id

    if not grequest.cached:
        reference_solutions = await getMostSelectedSolutions(db, requests)
        selected_solution_ids = list(reference_solutions.keys())

        solutions = await db.update(
            update(SolutionArchive)
            .where(SolutionArchive.id.in_(selected_solution_ids))
            .values(chosen=True)
            .returning(SolutionArchive)
        )
    else:
        solutions = (
            await db.all(select(SolutionArchive)
                .filter_by(problem=problem_id, chosen=True)
                .order_by(SolutionArchive.id.asc()))
        )

    return NIMBUSChosenResponse(
        chosen_solutions={sol.id: sol.objectives for sol in solutions},
        current_solutions={sol.id: sol.objectives for sol in solutions if sol.current},
    )


@router.post("/intermediate")
def intermediate(
    request: NIMBUSIntermediateSolutionRequest,
    user: Annotated[User, Depends(get_current_user)],
    db: Annotated[Session, Depends(get_db)],
) -> NIMBUSFullResponse | FakeNIMBUSResponse:
    """Get solutions between two solutions using NIMBUS.

    Args:
        request: The request body for a NIMBUS iteration.
        user (Annotated[User, Depends(get_current_user)]): The current user.
        db (Annotated[Session, Depends(get_db)]): The database session.

    Returns:
        The response from the NIMBUS algorithm.
    """
    # Do database stuff here.
    problem_id = request.problem_id
    method_id = request.method_id

    problem = db.query(ProblemInDB).filter(ProblemInDB.id == problem_id).first()
    if problem is None:
        raise HTTPException(status_code=404, detail="Problem not found.")
    # if problem.owner != user.index and problem.owner is not None:
        # raise HTTPException(status_code=403, detail="Unauthorized to access chosen problem.")
    try:
        problem = Problem.model_validate(problem.value)
    except ValidationError:
        raise HTTPException(status_code=500, detail="Error in parsing the problem.") from ValidationError

    previous_solutions = (
        db.query(SolutionArchive)
        .filter(SolutionArchive.problem == problem_id, SolutionArchive.user == user.index)
        .all()
    )
    if not previous_solutions:
        raise HTTPException(status_code=404, detail="Problem not found in the database.")

    ideal = problem.get_ideal_point()
    nadir = problem.get_nadir_point()
    if None in ideal or None in nadir:
        raise HTTPException(status_code=500, detail="Problem missing ideal or nadir value.")

    # Do NIMBUS stuff here.
    results = solve_intermediate_solutions(
        problem=problem,
        solution_1=dict(zip(problem.objectives, request.reference_solution_1, strict=True)),
        solution_2=dict(zip(problem.objectives, request.reference_solution_2, strict=True)),
        num_desired=request.num_solutions,
    )

    # See if the results include duplicates and remove them
    duplicate_indices = []
    for i in range(len(results) - 1):
        for j in range(i + 1, len(results)):
            if allclose(list(results[i].optimal_objectives.values()), list(results[i].optimal_objectives.values())):
                duplicate_indices.append(j)

    for index in sorted(duplicate_indices, reverse=True):
        results.pop(index)

    # Do database stuff again.
    # Save the given preferences
    pref = Preference(
        user=user.index,
        problem=problem_id,
        method=method_id,
        kind="NIMBUS_intermediate",
        value=request.model_dump(mode="json"),
    )
    db.add(pref)

    old_current_solutions = (
        db.query(SolutionArchive)
        .filter(SolutionArchive.problem == problem_id, SolutionArchive.user == user.index, SolutionArchive.current)
        .all()
    )

    # Mark all the old solutions as not current
    for old in old_current_solutions:
        old.current = False

    for res in results:
        # Check if the results already exist in the database
        for prev in previous_solutions:
            if allclose(res.optimal_objectives, prev.objectives):
                prev.current = True
                break
        # If the solution was not found in the database, add it
        if not prev.current:
            db.add(
                SolutionArchive(
                    user=user.index,
                    problem=problem_id,
                    method=method_id,
                    decision_variables=list(res.optimal_variables.values()),
                    objectives=list(res.optimal_objectives.values()),
                    saved=False,
                    current=True,
                    chosen=False,
                )
            )
    db.commit()

    solutions = (
        db.query(SolutionArchive)
        .filter(SolutionArchive.problem == problem_id, SolutionArchive.user == user.index)
        .all()
    )

    lower_bounds = [0.0 for x in range(len(problem.objectives))]
    upper_bounds = [0.0 for x in range(len(problem.objectives))]
    for i in range(len(problem.objectives)):
        if problem.objectives[i].maximize:
            lower_bounds[i] = nadir[problem.objectives[i].symbol]
            upper_bounds[i] = ideal[problem.objectives[i].symbol]
        else:
            lower_bounds[i] = ideal[problem.objectives[i].symbol]
            upper_bounds[i] = nadir[problem.objectives[i].symbol]

    return NIMBUSResponse(
        objective_symbols=[obj.symbol for obj in problem.objectives],
        objective_long_names=[obj.name for obj in problem.objectives],
        units=[obj.unit for obj in problem.objectives],
        is_maximized=[obj.maximize for obj in problem.objectives],
        lower_bounds=lower_bounds,
        upper_bounds=upper_bounds,
        previous_preference=request.preference,
        current_solutions=[sol.objectives for sol in solutions if sol.current],
        saved_solutions=[sol.objectives for sol in solutions if sol.saved],
        all_solutions=[sol.objectives for sol in solutions],
    )